<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>侍大喜利バトル！ルーム</title>
  <link href="https://fonts.googleapis.com/css2?family=Kaisei+Tokumin:wght@700&family=Noto+Serif+JP:wght@400;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --jp-main: #1a2a3a;
      --jp-accent: #c41c24;
      --jp-gold: #bb9900;
      --jp-bg: #f8f5e9;
      --jp-card: #fffdfa;
      --jp-outline: #7b3f00;
      --jp-muted: #ccc;
    }
    body {
      margin: 0;
      font-family: 'Noto Serif JP', serif;
      background: var(--jp-bg);
      min-height: 100vh;
    }
    .kaisei {
      font-family: 'Kaisei Tokumin', serif;
      letter-spacing: 2px;
      color: var(--jp-main);
    }
    .samurai-title {
      font-size: 2.2em;
      margin: 24px 0 14px 0;
      text-align: center;
      color: var(--jp-accent);
      text-shadow: 2px 2px 0 var(--jp-gold), 0 0 6px #fff6;
      border-bottom: 4px solid var(--jp-accent);
      border-image: linear-gradient(to right, var(--jp-accent), var(--jp-gold)) 1;
      padding-bottom: 10px;
    }
    .big { font-size: 1.6rem; font-weight: bold; margin-bottom: 12px; font-family: 'Kaisei Tokumin', serif; color: var(--jp-main);}
    .phase-block { margin: 24px 0; padding: 12px; background: var(--jp-card); border-radius: 8px; box-shadow: 0 1px 8px #ecd097; border: 2px solid var(--jp-outline);}
    /* ...残りのCSS省略。元のファイルのままOK！... */
  </style>
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.11.0/firebase-app.js";
    import { getFirestore, doc, collection, query, where, onSnapshot } from "https://www.gstatic.com/firebasejs/10.11.0/firebase-firestore.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.11.0/firebase-auth.js";

    const firebaseConfig = {
      apiKey: "AIzaSyCuqD00FZA-6E6D2efDRES7jx4mLyT_wGo",
      authDomain: "oogiri-game.firebaseapp.com",
      projectId: "oogiri-game",
      storageBucket: "oogiri-game.firebasestorage.app",
      messagingSenderId: "219076280601",
      appId: "1:219076280601:web:e07b5bc63d5692ec1d0588"
    };
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);
    signInAnonymously(auth)
      .then(() => {
        console.log("✅ 匿名ログイン成功！");
      })
      .catch((error) => {
        console.error("❌ 匿名ログイン失敗:", error);
      });

    const url = new URL(location.href);
    const roomId = url.searchParams.get("roomId");
    const userName = url.searchParams.get("userName");
    const userId = url.searchParams.get("userId");

    if (!userId) {
      alert('不正な遷移です。ロビーから入り直してください');
      location.href = '/lobby.html';
    }

    let myUid = null;
    let isHost = false;
    let phase = "waiting", round = 1, roundMax = 5, myHand = [], usedParticle = null;
    let answerTokens = [], answerDone = false, voted = false, voteTarget = null;
    let roomData = {}, roundData = {}, users = {}, points = {}, answers = {}, answerRevealOrder = [];
    let revealStep = 0;
    const PARTICLES = ["に","は","を","が","の","へ","と","より","から","で"];
    let themeVoteTimer = null, themeVoteTimeLeft = 0, themeVoteFinished = false;
    let usedChangeIdx = Array(9).fill(false), usedAllChange = false;
    let usedParticleThisRound = false;
    let selectedAnswerIdx = null;

    document.body.innerHTML = `
      <div class="samurai-title kaisei">侍大喜利バトルの間</div>
      <div class="big" id="title"></div>
      <div id="phaseArea" class="phase-block"></div>
      <div id="mainArea"></div>
      <div id="players" class="players-bar"></div>
    `;
    const titleEl = document.getElementById("title");
    const phaseEl = document.getElementById("phaseArea");
    const mainEl = document.getElementById("mainArea");
    const playersEl = document.getElementById("players");

    // --- ログイン状態でmyUid取得し、subscribe
    onAuthStateChanged(auth, (user) => {
      if (user) {
        myUid = user.uid;
        subscribeUsers();
        subscribeRoom();
        subscribeRound();
      }
    });

    // --- ユーザー一覧取得（isHost判定は廃止！）
    function subscribeUsers() {
      const q = query(collection(db, "users"), where("roomId", "==", roomId));
      onSnapshot(q, snap => {
        users = {}; points = {};
        myHand = [];
        snap.forEach(docx => {
          const d = docx.data();
          users[docx.id] = d;
          points[docx.id] = d.points || 0;
          if (docx.id === userId) {
            myHand = d.hand || [];
          }
        });
        renderPlayers();
        renderPhase();
      });
    }

    // --- room.ownerUidでホスト判定
    function subscribeRoom() {
      const roomRef = doc(db, "rooms", roomId);
      onSnapshot(roomRef, snap => {
        if (!snap.exists()) return;
        const oldRound = round;
        roomData = snap.data();
        phase = roomData.phase;
        round = roomData.round;
        roundMax = roomData.roundMax;
        isHost = (roomData.ownerUid === myUid); // ←ココのみ
        if (oldRound !== round) resetRoundState();
        renderPhase();
      });
    }

    function subscribeRound() {
      let oldRoundKey = "";
      let roundRef = null;
      function listen() {
        const newRoundKey = `${roomId}_${round}`;
        if (oldRoundKey === newRoundKey) return;
        oldRoundKey = newRoundKey;
        roundRef && roundRef();
        roundRef = onSnapshot(doc(db, "rounds", newRoundKey), snap => {
          if (!snap.exists()) return;
          roundData = snap.data();
          answers = roundData.answers || {};
          answerRevealOrder = roundData.answerRevealOrder || [];
          renderPhase();
        });
      }
      setInterval(listen, 500);
    }
    subscribeRound();

    function renderPhase() {
      titleEl.textContent = `ラウンド${round} / ${roundMax} - ${phaseLabel(phase)}`;
      mainEl.innerHTML = "";
      phaseEl.innerHTML = "";

      // ==== フェーズBGM切り替え修正 ====
      if (phase === "waiting") {
        soundManager.playBgm("lobby");
      } else if (phase === "theme_vote") {
        soundManager.playBgm("answer");
      } else if (phase === "answer") {
        soundManager.playBgm("answer");
      } else if (phase === "answer_reveal" || phase === "vote" || phase === "result" || phase === "end") {
        soundManager.playBgm("reveal");
      }
      // =================================

      if (phase === "waiting") {
        phaseEl.innerHTML = "全員が揃うまでお待ちください";
        if (Object.keys(users).length >= 2 && !roomData.started && isHost) {
          const btn = btnEl("ゲーム開始", async () => {
            await fetch(`/api/rooms/${roomId}/start`, { method: "POST" });
            soundManager.playSe("odaihappyou");
          });
          phaseEl.appendChild(btn);
        }
        clearThemeVoteTimer();
      }
      if (phase === "theme_vote") {
        phaseEl.innerHTML = `
          <div style="display:flex;align-items:center;font-size:1.2em;">
            <div>
              お題投票フェーズ(10秒制限)
              <span id="themeVoteTimer" class="timer" style="margin-left:0.7em;font-weight:bold;font-size:1.2em;"></span>
            </div>
          </div>  
        `;
        renderThemeVote();
       if (!themeVoteTimer) startThemeVoteTimer();
      } else {
        clearThemeVoteTimer();
      }
      if (phase === "theme_reveal") {
        phaseEl.innerHTML = "今回のお題は…";
        setTimeout(() => {
          phaseEl.innerHTML = `<div class="theme-big"><b>${roundData.theme || ""}</b></div>`;
          soundManager.playSe("odaihappyou");
        }, 2000);
        if (isHost) setTimeout(async () => {
          await fetch(`/api/rooms/${roomId}/rounds/${round}/answer-phase`, { method: "POST" });
        }, 5000);
      }
      if (phase === "answer") {
        phaseEl.innerHTML = `お題: <span style="font-weight:bold">${roundData.theme || ""}</span>`;
        renderAnswerArea();
      }
      if (phase === "answer_reveal") {
        renderAnswerRevealStep();
      }
      if (phase === "vote") {
        phaseEl.innerHTML = "投票フェーズ";
        renderVoteArea();
        setTimeout(() => {
          if (isHost && phase === "vote" && allVotesIn()) {
            fetch(`/api/rooms/${roomId}/rounds/${round}/result-phase`, { method: "POST" });
          }
        }, 1000);
      }
      if (phase === "result") {
        soundManager.playSe("kannsei", 0.85);
        renderResultArea();
      }
      if (phase === "end") {
        phaseEl.innerHTML = "<b>全ラウンド終了！</b>";
        renderFinalResult();
      }
    }

    function startThemeVoteTimer() {
      themeVoteTimeLeft = 10;
      themeVoteFinished = false;
      updateThemeVoteTimer();
      themeVoteTimer = setInterval(() => {
        themeVoteTimeLeft--;
        updateThemeVoteTimer();
        if (themeVoteTimeLeft <= 0) {
          clearThemeVoteTimer();
          themeVoteFinished = true;
          if (isHost && phase === "theme_vote") {
            fetch(`/api/rooms/${roomId}/rounds/${round}/answer-reveal`, { method: "POST" });
          }
        } else {
          if (isHost && phase === "theme_vote" && allVoted()) {
            clearThemeVoteTimer();
            fetch(`/api/rooms/${roomId}/rounds/${round}/answer-reveal`, { method: "POST" });
          }
        }
      }, 1000);
    }
    function updateThemeVoteTimer() {
      let tEl = document.getElementById("themeVoteTimer");
      if (!tEl) {
        tEl = document.createElement("div");
        tEl.id = "themeVoteTimer";
        tEl.className = "timer";
        phaseEl.prepend(tEl);
      }
      tEl.textContent = `残り時間: ${themeVoteTimeLeft}秒`;
    }
    function clearThemeVoteTimer() {
      if (themeVoteTimer) clearInterval(themeVoteTimer);
      themeVoteTimer = null;
      let tEl = document.getElementById("themeVoteTimer");
      if (tEl) tEl.remove();
    }
    function allVoted() {
      if (!roundData || !roundData.themeVotes) return false;
      return Object.keys(users).every(uid => uid in roundData.themeVotes);
    }

    function renderThemeVote() {
      mainEl.innerHTML = "";
      if (!roundData.themes) return;
      let myVoteIdx = null;
      if (roundData.themeVotes && roundData.themeVotes[userId] != null) myVoteIdx = roundData.themeVotes[userId];
      roundData.themes.forEach((th, idx) => {
        const btn = document.createElement("button");
        btn.className = "btn";
        btn.textContent = th;
        if (myVoteIdx === idx || themeVoteFinished) btn.disabled = true;
        btn.onclick = async () => {
          await fetch(`/api/rooms/${roomId}/rounds/${round}/theme-vote`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ userId, themeIndex: idx })
          });
        };
        mainEl.appendChild(btn);
      });
    }

    function renderAnswerArea() {
      answerArea.className = "answer-area";
      updateAnswerArea();
      mainEl.innerHTML = "";
      mainEl.appendChild(answerArea);

      const handWrap = document.createElement("div");
      handWrap.className = "hand-cards";
      myHand.forEach((w, i) => {
        const block = document.createElement("div");
        block.className = "hand-card-block";
        const card = document.createElement("div");
        card.className = "hand-card";
        if (i < 4) card.classList.add("general");
        else if (i < 6) card.classList.add("funny");
        else if (i == 6) card.classList.add("adverb");
        else card.classList.add("verb");
        let size = 1.1;
        if (w.length > 7) size = Math.max(0.75, 1.1 - (w.length-7)*0.06);
        card.style.fontSize = size+"rem";
        card.textContent = w;
        if (answerTokens.filter(x=>x.type=='word').map(x=>x.idx).includes(i)) card.classList.add("used");
        card.onclick = () => {
          if (answerDone) return;
          if (answerTokens.filter(x=>x.type=='word').map(x=>x.idx).includes(i)) return;
          if (selectedAnswerIdx !== null) {
            answerTokens.splice(selectedAnswerIdx+1,0,{ type: "word", idx: i });
          } else {
            answerTokens.push({ type: "word", idx: i });
          }
          selectedAnswerIdx = null;
          updateAnswerArea();
        };
        block.appendChild(card);

        const cbtn = document.createElement("button");
        cbtn.className = "change-btn";
        cbtn.innerHTML = "⟳";
        if (usedChangeIdx[i] || answerDone) cbtn.disabled = true;
        cbtn.onclick = async () => {
          if (usedChangeIdx[i] || answerDone) return;
          cbtn.disabled = true;
          usedChangeIdx[i] = true;
          await fetch(`/api/users/${userId}/hand`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ changeType: "one", cardIdx: i })
          });
        };
        block.appendChild(cbtn);

        handWrap.appendChild(block);
      });
      mainEl.appendChild(handWrap);

      const particleWrap = document.createElement("div");
      particleWrap.className = "controls";
      PARTICLES.forEach(pt => {
        const pbtn = document.createElement("button");
        pbtn.className = "particle-btn";
        pbtn.textContent = pt;
        if (usedParticleThisRound) pbtn.disabled = true;
        pbtn.onclick = () => {
          if (answerDone || usedParticleThisRound) return;
          if (selectedAnswerIdx !== null) {
            answerTokens.splice(selectedAnswerIdx+1,0,{ type: "particle", value: pt });
          } else {
            answerTokens.push({ type: "particle", value: pt });
          }
          usedParticleThisRound = true;
          selectedAnswerIdx = null;
          updateAnswerArea();
        };
        particleWrap.appendChild(pbtn);
      });
      mainEl.appendChild(particleWrap);

      const controls = document.createElement("div");
      controls.className = "controls";
      const allChangeBtn = btnEl("オールチェンジ", async () => {
        if (usedAllChange || answerDone) return;
        usedAllChange = true;
        allChangeBtn.disabled = true;
        const usedIdxs = answerTokens.filter(x => x.type == "word").map(x => x.idx);
        let newHand = [...myHand];
        const res = await fetch(`/api/users/${userId}/hand`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ changeType: "all", keepIdx: usedIdxs })
        });
        const data = await res.json();
        if (data.hand) newHand = data.hand;
        for (let i = 0; i < myHand.length; ++i) {
          if (!usedIdxs.includes(i)) {
            myHand[i] = newHand[i];
          }
        }
      });
      if (usedAllChange) allChangeBtn.disabled = true;
      controls.appendChild(allChangeBtn);

      const clearBtn = btnEl("作成クリア", () => {
        if (answerDone) return;
        answerTokens = [];
        usedParticleThisRound = false;
        updateAnswerArea();
      });
      controls.appendChild(clearBtn);

      const sendBtn = btnEl("回答送信！", async () => {
        if (answerDone || !answerTokens.length) return;
        answerDone = true;
        let ans = "";
        answerTokens.forEach(x => {
          if (x.type == "word") ans += myHand[x.idx];
          else if (x.type == "particle") ans += x.value;
        });
        await fetch(`/api/rooms/${roomId}/rounds/${round}/answer`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            userId,
            answer: ans,
            usedWords: answerTokens.filter(x=>x.type=='word').map(x=>x.idx)
          })
        });
      });
      if (answerDone) sendBtn.disabled = true;
      controls.appendChild(sendBtn);

      mainEl.appendChild(controls);
    }

    function updateAnswerArea() {
      answerArea.innerHTML = "";
      answerTokens.forEach((t, i) => {
        const span = document.createElement("span");
        span.className = "answer-token";
        if (t.type == "particle") span.classList.add("particle");
        span.textContent = (t.type == "word") ? myHand[t.idx] : t.value;
        if (selectedAnswerIdx === i) span.classList.add("selected");
        span.onclick = () => {
          if (answerDone) return;
          if (selectedAnswerIdx === i) selectedAnswerIdx = null;
          else selectedAnswerIdx = i;
          updateAnswerArea();
        };
        answerArea.appendChild(span);
      });
    }

    // === 回答発表時: フェードアウト→回答表示→SE（kaitouhappyou→waraigoe）→BGM復帰 ===
function renderAnswerRevealStep() {
  mainEl.innerHTML = "";
  if (!answerRevealOrder.length) return;
  const step = revealStep % answerRevealOrder.length;
  const uid = answerRevealOrder[step];
  const ans = (roundData.answers && roundData.answers[uid]) ? roundData.answers[uid].answer : "";
  const theme = roundData.theme || "";
  phaseEl.innerHTML = `<div class="theme-big"><b>${theme}</b></div>`;

  // ★★delay設定（今までと同じ）★★
  let delay = 1200;
  if (step === 0) delay += 3000;

  // ★ 回答表示タイミングの1秒前にフェードアウト開始！
  setTimeout(() => {
    soundManager.fadeOutBgm(1000);

    setTimeout(() => {
      // 2. 一瞬静かにしてから回答表示
      mainEl.innerHTML = `<div class="theme-big">${ans}</div>`;

      // 3. 回答表示と同時にSE
      soundManager.playSe("kaitouhappyou");
      setTimeout(() => {
        soundManager.playSe("waraigoe", 0.05);
      }, 700);

      // 4. さらにちょっと待ってBGMフェードイン
      setTimeout(() => {
        soundManager.fadeInBgm(800);
      }, 1700);

      // 5. 次の回答 or フェーズ遷移
      setTimeout(() => {
        revealStep++;
        if (revealStep < answerRevealOrder.length) {
          renderAnswerRevealStep();
        } else {
          if (isHost) {
            fetch(`/api/rooms/${roomId}/rounds/${round}/vote-phase`, { method: "POST" });
          }
        }
      }, 5700);
    }, 1500); // フェードアウト終わったら回答表示

  }, delay - 1000); // 回答表示タイミングの1秒前にフェードアウト開始
}

    function renderVoteArea() {
      mainEl.innerHTML = "";
      if (!roundData || !roundData.answers) return;
      Object.entries(roundData.answers).forEach(([uid, ans]) => {
        const btn = document.createElement("button");
        btn.className = "vote-btn";
        btn.textContent = ans.answer;
        if (uid === userId) {
          btn.disabled = true; btn.style.opacity = "0.5";
        }
        if (voted && voteTarget === uid) btn.classList.add("voted");
        btn.onclick = async () => {
          if (voted) return;
          await fetch(`/api/rooms/${roomId}/rounds/${round}/vote`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ userId, voteForUserId: uid })
          });
          voted = true; voteTarget = uid;
          btn.classList.add("voted");
          if (isHost && allVotesIn()) {
            setTimeout(() => {
              fetch(`/api/rooms/${roomId}/rounds/${round}/result-phase`, { method: "POST" });
            }, 800);
          }
        };
        mainEl.appendChild(btn);
      });
    }
    function allVotesIn() {
      if (!roundData || !roundData.votes) return false;
      return Object.keys(users).every(uid => roundData.votes[uid]);
    }

    function renderResultArea() {
      mainEl.innerHTML = "";
      if (!roundData.result) return;
      let maxVote = 0;
      Object.values(roundData.result).forEach(v => { if (v > maxVote) maxVote = v; });
      Object.entries(roundData.result).forEach(([uid, cnt]) => {
        if (!users[uid]) return;
        let answerText = (roundData.answers && roundData.answers[uid]) ? roundData.answers[uid].answer : "";
        const div = document.createElement("div");
        div.textContent = `${users[uid].userName}：${answerText} ${cnt}ポイント！`;
        div.style.fontSize = "1.3em";
        if (cnt === maxVote) div.style.color = "#e54c2a";
        mainEl.appendChild(div);
      });
      if (isHost) {
        const btn = btnEl("次ラウンドへ", async () => {
          await fetch(`/api/rooms/${roomId}/next`, { method: "POST" });
        });
        mainEl.appendChild(btn);
      }
    }

    function renderFinalResult() {
      mainEl.innerHTML = "<h2>最終結果発表！</h2>";
      let maxPt = 0;
      Object.values(points).forEach(pt => { if (pt > maxPt) maxPt = pt; });
      Object.entries(points).forEach(([uid, pt]) => {
        if (!users[uid]) return;
        const div = document.createElement("div");
        div.textContent = `${users[uid].userName}：${pt} ポイント`;
        div.style.fontSize = "1.2em";
        if (pt === maxPt) div.style.color = "#e54c2a";
        mainEl.appendChild(div);
      });
      if (isHost) {
        const restartBtn = document.createElement("button");
        restartBtn.className = "restart-btn";
        restartBtn.textContent = "再戦する";
        restartBtn.onclick = async () => {
          await Promise.all(Object.keys(users).map(uid =>
            fetch(`/api/users/${uid}`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ points: 0 })
            })));
          await fetch(`/api/rooms/${roomId}/restart`, { method: "POST" });
        };
        mainEl.appendChild(restartBtn);
      }
    }

    function renderPlayers() {
      playersEl.innerHTML = "";
      Object.entries(users).forEach(([uid, u]) => {
        const div = document.createElement("div");
        div.textContent = `${u.userName}（${u.points||0}pt）`;
        div.style.display = "inline-block";
        div.style.margin = "0 10px 0 0";
        div.style.fontWeight = "bold";
        playersEl.appendChild(div);
      });
    }

    function btnEl(label, onclick) {
      const btn = document.createElement("button");
      btn.className = "btn";
      btn.textContent = label;
      btn.onclick = onclick;
      return btn;
    }

    function phaseLabel(phase) {
      return {
        waiting: "待機",
        theme_vote: "お題投票",
        theme_reveal: "お題発表",
        answer: "回答作成",
        answer_reveal: "回答発表",
        vote: "投票",
        result: "ポイント結果発表",
        end: "最終結果"
      }[phase] || phase;
    }
  </script>
</head>
<body>
</body>
</html>
